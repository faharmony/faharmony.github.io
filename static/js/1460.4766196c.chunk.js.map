{"version":3,"file":"static/js/1460.4766196c.chunk.js","mappings":"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","sources":["../../node_modules/codemirror-graphql/src/utils/forEachState.ts","../../node_modules/codemirror-graphql/src/utils/hintList.ts","../../node_modules/codemirror-graphql/src/variables/hint.ts"],"sourcesContent":["/**\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport type { State, Maybe } from 'graphql-language-service';\n\n// Utility for iterating through a CodeMirror parse state stack bottom-up.\nexport default function forEachState(stack: State, fn: (state: State) => void) {\n  const reverseStateStack = [];\n  let state: Maybe<State> = stack;\n  while (state?.kind) {\n    reverseStateStack.push(state);\n    state = state.prevState;\n  }\n  for (let i = reverseStateStack.length - 1; i >= 0; i--) {\n    fn(reverseStateStack[i]);\n  }\n}\n","/**\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport type CodeMirror from 'codemirror';\nimport { IHint, IHints } from '../hint';\n\n// Create the expected hint response given a possible list and a token\nexport default function hintList(\n  cursor: CodeMirror.Position,\n  token: CodeMirror.Token,\n  list: IHint[],\n): IHints | undefined {\n  const hints = filterAndSortList(list, normalizeText(token.string));\n  if (!hints) {\n    return;\n  }\n\n  const tokenStart =\n    token.type !== null && /\"|\\w/.test(token.string[0])\n      ? token.start\n      : token.end;\n\n  return {\n    list: hints,\n    from: { line: cursor.line, ch: tokenStart }, // TODO: Confirm. Was changed column to ch\n    to: { line: cursor.line, ch: token.end },\n  };\n}\n\n// Given a list of hint entries and currently typed text, sort and filter to\n// provide a concise list.\nfunction filterAndSortList(list: IHint[], text: string) {\n  if (!text) {\n    return filterNonEmpty(list, entry => !entry.isDeprecated);\n  }\n\n  const byProximity = list.map(entry => ({\n    proximity: getProximity(normalizeText(entry.text), text),\n    entry,\n  }));\n\n  const conciseMatches = filterNonEmpty(\n    filterNonEmpty(byProximity, pair => pair.proximity <= 2),\n    pair => !pair.entry.isDeprecated,\n  );\n\n  const sortedMatches = conciseMatches.sort(\n    (a, b) =>\n      (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) ||\n      a.proximity - b.proximity ||\n      a.entry.text.length - b.entry.text.length,\n  );\n\n  return sortedMatches.map(pair => pair.entry);\n}\n\n// Filters the array by the predicate, unless it results in an empty array,\n// in which case return the original array.\nfunction filterNonEmpty<T>(array: T[], predicate: (item: T) => boolean) {\n  const filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\n\nfunction normalizeText(text: string) {\n  return text.toLowerCase().replace(/\\W/g, '');\n}\n\n// Determine a numeric proximity for a suggestion based on current text.\nfunction getProximity(suggestion: string, text: string) {\n  // start with lexical distance\n  let proximity = lexicalDistance(text, suggestion);\n  if (suggestion.length > text.length) {\n    // do not penalize long suggestions.\n    proximity -= suggestion.length - text.length - 1;\n    // penalize suggestions not starting with this phrase\n    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n  }\n  return proximity;\n}\n\n/**\n * Computes the lexical distance between strings A and B.\n *\n * The \"distance\" between two strings is given by counting the minimum number\n * of edits needed to transform string A into string B. An edit can be an\n * insertion, deletion, or substitution of a single character, or a swap of two\n * adjacent characters.\n *\n * This distance can be useful for detecting typos in input or sorting\n *\n * @param {string} a\n * @param {string} b\n * @return {int} distance in number of edits\n */\nfunction lexicalDistance(a: string, b: string) {\n  let i;\n  let j;\n  const d = [];\n  const aLength = a.length;\n  const bLength = b.length;\n\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n\n      d[i][j] = Math.min(\n        d[i - 1][j] + 1,\n        d[i][j - 1] + 1,\n        d[i - 1][j - 1] + cost,\n      );\n\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n\n  return d[aLength][bLength];\n}\n","/**\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport CodeMirror, { Hints } from 'codemirror';\nimport {\n  getNullableType,\n  getNamedType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLList,\n  GraphQLBoolean,\n  GraphQLInputType,\n  GraphQLInputFieldMap,\n} from 'graphql';\nimport type { State, Maybe } from 'graphql-language-service';\nimport { IHints } from '../hint';\n\nimport forEachState from '../utils/forEachState';\nimport hintList from '../utils/hintList';\n\nexport type VariableToType = Record<string, GraphQLInputType>;\ninterface GraphQLVariableHintOptions {\n  variableToType: VariableToType;\n}\n\ndeclare module 'codemirror' {\n  interface ShowHintOptions {\n    variableToType?: VariableToType;\n  }\n\n  interface CodeMirrorHintMap {\n    'graphql-variables': (\n      editor: CodeMirror.Editor,\n      options: GraphQLVariableHintOptions,\n    ) => IHints | undefined;\n  }\n}\n\n/**\n * Registers a \"hint\" helper for CodeMirror.\n *\n * Using CodeMirror's \"hint\" addon: https://codemirror.net/demo/complete.html\n * Given an editor, this helper will take the token at the cursor and return a\n * list of suggested tokens.\n *\n * Options:\n *\n *   - variableToType: { [variable: string]: GraphQLInputType }\n *\n * Additional Events:\n *\n *   - hasCompletion (codemirror, data, token) - signaled when the hinter has a\n *     new list of completion suggestions.\n *\n */\nCodeMirror.registerHelper(\n  'hint',\n  'graphql-variables',\n  (\n    editor: CodeMirror.Editor,\n    options: GraphQLVariableHintOptions,\n  ): Hints | undefined => {\n    const cur = editor.getCursor();\n    const token = editor.getTokenAt(cur);\n\n    const results = getVariablesHint(cur, token, options);\n    if (results?.list && results.list.length > 0) {\n      results.from = CodeMirror.Pos(results.from.line, results.from.ch);\n      results.to = CodeMirror.Pos(results.to.line, results.to.ch);\n      CodeMirror.signal(editor, 'hasCompletion', editor, results, token);\n    }\n\n    return results;\n  },\n);\n\nfunction getVariablesHint(\n  cur: CodeMirror.Position,\n  token: CodeMirror.Token,\n  options: GraphQLVariableHintOptions,\n) {\n  // If currently parsing an invalid state, attempt to hint to the prior state.\n  const state =\n    token.state.kind === 'Invalid' ? token.state.prevState : token.state;\n\n  const kind = state.kind;\n  const step = state.step;\n\n  // Variables can only be an object literal.\n  if (kind === 'Document' && step === 0) {\n    return hintList(cur, token, [{ text: '{' }]);\n  }\n\n  const variableToType = options.variableToType;\n  if (!variableToType) {\n    return;\n  }\n\n  const typeInfo = getTypeInfo(variableToType, token.state);\n\n  // Top level should typeahead possible variables.\n  if (kind === 'Document' || (kind === 'Variable' && step === 0)) {\n    const variableNames = Object.keys(variableToType);\n    return hintList(\n      cur,\n      token,\n      variableNames.map(name => ({\n        text: `\"${name}\": `,\n        type: variableToType[name],\n      })),\n    );\n  }\n\n  // Input Object fields\n  if (kind === 'ObjectValue' || (kind === 'ObjectField' && step === 0)) {\n    if (typeInfo.fields) {\n      const inputFields = Object.keys(typeInfo.fields).map(\n        fieldName => typeInfo.fields![fieldName],\n      );\n      return hintList(\n        cur,\n        token,\n        inputFields.map(field => ({\n          text: `\"${field.name}\": `,\n          type: field.type,\n          description: field.description,\n        })),\n      );\n    }\n  }\n\n  // Input values.\n  if (\n    kind === 'StringValue' ||\n    kind === 'NumberValue' ||\n    kind === 'BooleanValue' ||\n    kind === 'NullValue' ||\n    (kind === 'ListValue' && step === 1) ||\n    (kind === 'ObjectField' && step === 2) ||\n    (kind === 'Variable' && step === 2)\n  ) {\n    const namedInputType = typeInfo.type\n      ? getNamedType(typeInfo.type)\n      : undefined;\n    if (namedInputType instanceof GraphQLInputObjectType) {\n      return hintList(cur, token, [{ text: '{' }]);\n    } else if (namedInputType instanceof GraphQLEnumType) {\n      const values = namedInputType.getValues();\n      // const values = Object.keys(valueMap).map(name => valueMap[name]); // TODO: Previously added\n      return hintList(\n        cur,\n        token,\n        values.map(value => ({\n          text: `\"${value.name}\"`,\n          type: namedInputType,\n          description: value.description,\n        })),\n      );\n    } else if (namedInputType === GraphQLBoolean) {\n      return hintList(cur, token, [\n        { text: 'true', type: GraphQLBoolean, description: 'Not false.' }, // TODO: type and description don't seem to be used. Added them as optional anyway.\n        { text: 'false', type: GraphQLBoolean, description: 'Not true.' },\n      ]);\n    }\n  }\n}\ninterface VariableTypeInfo {\n  type?: Maybe<GraphQLInputType>;\n  fields?: Maybe<GraphQLInputFieldMap>;\n}\n// Utility for collecting rich type information given any token's state\n// from the graphql-variables-mode parser.\nfunction getTypeInfo(\n  variableToType: Record<string, GraphQLInputType>,\n  tokenState: State,\n) {\n  const info: VariableTypeInfo = {\n    type: null,\n    fields: null,\n  };\n\n  forEachState(tokenState, state => {\n    if (state.kind === 'Variable') {\n      info.type = variableToType[state.name!];\n    } else if (state.kind === 'ListValue') {\n      const nullableType = info.type ? getNullableType(info.type) : undefined;\n      info.type =\n        nullableType instanceof GraphQLList ? nullableType.ofType : null;\n    } else if (state.kind === 'ObjectValue') {\n      const objectType = info.type ? getNamedType(info.type) : undefined;\n      info.fields =\n        objectType instanceof GraphQLInputObjectType\n          ? objectType.getFields()\n          : null;\n    } else if (state.kind === 'ObjectField') {\n      const objectField =\n        state.name && info.fields ? info.fields[state.name] : null;\n      info.type = objectField?.type;\n    }\n  });\n\n  return info;\n}\n"],"names":["exports","stack","fn","reverseStateStack","state","kind","push","prevState","i","length","filterNonEmpty","array","predicate","filtered","filter","normalizeText","text","toLowerCase","replace","getProximity","suggestion","proximity","a","b","j","d","aLength","bLength","cost","Math","min","lexicalDistance","indexOf","cursor","token","list","hints","entry","isDeprecated","byProximity","map","pair","sort","filterAndSortList","string","tokenStart","type","test","start","end","from","line","ch","to","codemirror_1","__importDefault","require","graphql_1","forEachState_1","hintList_1","default","registerHelper","editor","options","cur","getCursor","getTokenAt","results","step","variableToType","typeInfo","tokenState","info","fields","name","nullableType","getNullableType","undefined","GraphQLList","ofType","objectType","getNamedType","GraphQLInputObjectType","getFields","objectField","getTypeInfo","variableNames","Object","keys","concat","inputFields","fieldName","field","description","namedInputType_1","GraphQLEnumType","values","getValues","value","GraphQLBoolean","getVariablesHint","Pos","signal"],"sourceRoot":""}